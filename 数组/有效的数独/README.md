# 移动零
> 源地址：https://leetcode-cn.com/explore/featured/card/top-interview-questions-easy/1/array/28/

判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 '.' 表示。

示例 1:
```
输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
```
示例 2:
```
输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
```
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。

### 思路分析
这一题最关键的就是知道题目到底考验我们什么，我认为它最关键的地方就是怎么判断一个长度为9的数组中的数字只有1-9且不重复。这样的话我们只要写一个判断它的方法，然后调用 9(行) + 9(列) + 9(空格) 就行了，所以判断方法的效率很重要。我采用了 HashSet 来判断，将9个值中除 '.' 的字符放进一个 hashset，再跟我累加的字符长度做比较判断是不是有重复的字符。但是实际发现还有个问题在于如何获取3*3小九宫格里的9个数组，这里遍历过程我用了3个嵌套数组。

后面我想了下没有必要，可以提前建立一个二维数组，在列和行的遍历过程中通过行和列的计算获取当前值是属于第几个3*3小九宫格，然后二维数组的行表示第几个方格，列表示出现数组，值表示是否出现。

```
例如：初始化二维数组 flag[9][9]
那么 flag[1][8] 就表示 第【2】个方格中出现过数字【9】。
```


### 代码展示
我的代码：
```java
public boolean isValidSudoku(char[][] board) {
        Set<Character> set = new HashSet<>();
        int len = 0, i = 0;
        for(; i<9; i++) {
            set.clear();
            len = 0;
            for(int j=0; j<9; j++) {
                if(board[i][j] != '.') {
                    len++;
                    set.add(board[i][j]);
                }
            }
            if(set.size() != len) {
                return false;
            }

            set.clear();
            len = 0;
            for(int j=0; j<9; j++) {
                if(board[j][i] != '.') {
                    len++;
                    set.add(board[j][i]);
                }
            }
            if(set.size() != len) {
                return false;
            }
        }
        
        i = 0;
        while(i<9) {
            set.clear();
            len = 0;
            for(int j=(i%3)*3; j<(i%3+1)*3; j++) {
                for(int k=(i/3)*3; k<(i/3+1)*3; k++) {
                    if(board[j][k] != '.') {
                        len++;
                        set.add(board[j][k]);
                    }
                }
            }
            if(set.size() != len) {
                return false;
            }
            i++;
        }

        return true;
    }
}
```
优化后的代码：
```java
public boolean isValidSudoku(char[][] board) {
    boolean[][] rowFlag = new boolean[9][9];
    boolean[][] colFlag = new boolean[9][9];
    boolean[][] cellFlag = new boolean[9][9];

    for (int i = 0; i < 9; ++i) {
        for (int j = 0; j < 9; ++j) {
            if (board[i][j] >= '1' && board[i][j] <= '9') {
                int c = board[i][j] - '1';
                if (rowFlag[i][c] || colFlag[c][j] || cellFlag[3 * (i / 3) + j / 3][c]) return false;
                rowFlag[i][c] = true;
                colFlag[c][j] = true;
                cellFlag[3 * (i / 3) + j / 3][c] = true;
            }
        }
    }
    return true;
}
```
